
递归设计考虑基本要素：
0.拆分成子问题
1.上层值传递关系
     value=func(param)
     value  上层的返回值传到此层，一般用于后续遍历
     param  此层的输出作为下层函数传递参数，一般用于先序遍历
2.变量：
    虚变量    只在每层有效，下一层是一个新变量  例如 原型变量传递
    global变量  下一层不需要自己编程就知道上层的值，累加遍历的历史， 例如 对象传递 注意(string stringBuffer)的区分
3.顺序：
    先序  problem=1+ problem(n-1) 逐步分解， 类似于揪面团里的一小块
    后序  divide(problem)=1....n; problem=1+....+n  类似于切好成所有小面团然后包饺子
    中序

步骤：
1.算法
2.边界条件
3.presentation

####递归中的错误
  *变量在递归函数内是否是增量更新，还是虚对象，极为混乱

public List<String> recursive( List<String> list,TreeNode root,String path){
	        if(root ==null ) return list;
	         path += "".equals(path)?root.val:"->"+root.val;
--path增量更新？值传递和引用传递？
复习下面两个情况

StringBuffer a= new StringBuffer();
	    	a.append("aaaaa");
	    	s.write(a);
	    	System.out.println(a);
public void write(StringBuffer a){
	    	a.append("sss");
	    	System.out.println("===="+a.hashCode());
	    }


StringBuffer a= "";
	    	a+="aaaaa";
	    	s.write(a);
	    	System.out.println(a);
public void write(String a){
	    	a+="sss";
	    	System.out.println("===="+a.hashCode());
	    }



--> 结论: 
    模板结构: 
           recursive(StringBuffer path)
              path.append ....   //增量更新path内容
           用途：递归问题中记录遍历过得数据的历史，例如 leetcode 257 每条path

           recursive(String path)
              path += ....   //虚对象，不需要增量积累信息 只是需要运用本节点在本层中做处理
           用途：不需要记录前面遍历过整条path的路径，只需要记录本层节点的情况，传递给下一层


    *递归传递：两种形式
      value=recursion(param)
        value 适合后续遍历
        param 适合前序遍历



